#define CONNECTION  1
//modification de search pour envoyer des messages par bt qd on est leader
#define SERV_NAME   "eurecom-os-server"             // The name of the server
#define MSG_ACTION  0
#define MSG_ACK     1
#define MSG_LEAD    2
#define MSG_START   3
#define MSG_STOP    4
#define MSG_WAIT    5
#define MSG_CUSTOM  6
#define MSG_KICK    7
#define ACHILLE     8

#define COMPASS_PORT        S1
#define COLOR_PORT          S2
#define LIGHT_PORT          S3
#define US_PORT             S4

#define LEFT_MOTOR           OUT_C
#define RIGHT_MOTOR          OUT_A
#define BOTH_MOTORS          OUT_AC

#define COLOR_GREEN          4
#define COLOR_RED            9
#define COLOR_BLUE           3
//WHITE : >10

#define SERV    1


//#define 	Sin(_X)   asm { sin __FLTRETVAL__, _X }
//#define 	Cos(_X)   asm { cos __FLTRETVAL__, _X }

int ref_y_axis=0;
int ref_x_axis=0;
float dist_x=0;
float dist_y=0;

int dist_search=0;

byte next_rob;
byte msg[];
byte msgOut[];
byte id[];

mutex msgOutMutex;


task search();
task explore();

void joy()
{
  PlayTone(TONE_E4, MS_100);
  Wait(MS_100);
  PlayTone(TONE_G4, MS_100);
  Wait(MS_100);
  PlayTone(TONE_C5, MS_100);
  Wait(MS_100);
  PlayTone(TONE_E5, MS_100);
  Wait(MS_100);
  PlayTone(TONE_G5, MS_300);
  Wait(MS_300);
  PlayTone(TONE_E5, MS_100);
  Wait(MS_100);
  PlayTone(TONE_G5, SEC_1);
  Wait(SEC_1);
}


char getMessage (byte &msg[]) {
  until (BluetoothStatus(CONNECTION) == NO_ERR);  // Wait for connection
  string __msg;
  char r = ReceiveMessage(0,1,__msg);
  if (r != 0)
  return 0;

  ArrayInit(msg,0,59);
  StrToByteArray (__msg, msg);
  r = ArrayLen(msg);
  if (r < 5)
  return 0;

  return r;
}

void sendMessage (byte msg[]) {
  CommBTWriteType args2;
  args2.Connection = CONNECTION;
  args2.Buffer= ByteArrayToStr (msg);

  SysCommBTWrite(args2);
  TextOut(0, LCD_LINE2,       "Trying to write");
  while (BluetoothStatus (CONNECTION) == STAT_COMM_PENDING)
  Wait (10);

  if (BluetoothStatus (CONNECTION) == NO_ERR)
  TextOut(0, LCD_LINE2,   "Write Done     ");
  else
  TextOut(0, LCD_LINE2,   "Write Failed   ");
}

int send_wait(byte dest, float delay)
{
  string del=FlattenVar(delay);
  string deb="delay: "+NumToStr(delay)+"length del: "+NumToStr(ArrayLen(del))+"del[0]: "+del[0]+"del[1]: "+del[1];
  SendResponseString(MAILBOX10, deb);
  ArrayInit(msgOut, 0, 6);
  msgOut[0] = id[0];
  msgOut[1] = id[1];
  msgOut[2] = 0x08;
  msgOut[3] = next_rob;                    //byte or int
  msgOut[4] = MSG_WAIT;
  msgOut[6] = del[0];

  sendMessage(msgOut);
  return 1;
}

int send_action(byte dest, int angle, int dist, int speed){
  string ang=FlattenVar(angle); // Int to string
  dist=dist*100; // dist in cm not m.
  string di=FlattenVar(dist);
  speed=speed*1000; // speed in mm.s-1 not m.s-1
  string spee=FlattenVar(speed);

  string deb1="angle: "+NumToStr(angle)+"ang[0]: "+ang[0]+" ang[1]: "+ang[1];
  string deb2="speed: "+NumToStr(speed)+"spee[0]: "+spee[0]+" spee[1]: "+spee[1];
  string deb3="dist: "+NumToStr(dist)+"di: "+di[0];
  SendResponseString(MAILBOX10, deb1);
  SendResponseString(MAILBOX10, deb2);
  SendResponseString(MAILBOX10, deb3);

  ArrayInit(msgOut, 0, 10);
  msgOut[0]=id[0];
  msgOut[1]=id[1];
  msgOut[2]=ACHILLE;
  msgOut[3]=dest,
  msgOut[4]=MSG_ACTION;
  msgOut[5]=ang[0];
  msgOut[6]=ang[1];
  msgOut[7]=di;
  msgOut[8]=spee[0];
  msgOut[9]=spee[1];

  sendMessage(msgOut);
  return 1;
}

int send_lead(byte dest){
  ArrayInit(msgOut, 0, 5);
  msgOut[0]=id[0];
  msgOut[1]=id[1];
  msgOut[2]=ACHILLE;
  msgOut[3]=dest;
  msgOut[4]=MSG_LEAD;

  sendMessage(msgOut);
  return 1;
}

int turn(short angle, short ref){
  int end =0;
  int obj=ref+angle;
  while(obj<0){
    obj+=360;
  }
  obj=obj%360;

  int compValue=SensorHTCompass(COMPASS_PORT);

  #ifdef SERV
    Acquire(msgOutMutex);                         // delay in sec !!??? Need to send a wait msg?
    send_wait(next_rob, abs(compValue-obj)/90);   // Approx
    Release(msgOutMutex);
  #endif

  while(compValue > obj){
    OnFwd(OUT_A, 30);// turn left
    OnRev(OUT_C,30);
    compValue=SensorHTCompass(COMPASS_PORT);
  }
  while(compValue < obj){
    OnFwd(OUT_C, 30); // turn right
    OnRev(OUT_A,30);
    compValue=SensorHTCompass(COMPASS_PORT);
  }
  end=1;
}

float speed(int pow){
  return 0.0039*pow-0.0293;
}

int forward_plus(float dist, int pow, int angle){
  float time=dist/speed(pow);
  float alpha=(angle-ref_x_axis);

  #ifdef SERV
    Acquire(msgOutMutex);
    send_action(next_rob, angle-ref_y_axis, dist, speed(pow)); // angle=curr_angle-angle_init
    Release(msgOutMutex);
  #endif

  dist_x=dist_x+dist*Cos(alpha)/100;
  dist_y=dist_y+dist*Sin(alpha)/100;

  string deb="alpha: "+NumToStr(alpha)+" "+"distx: "+NumToStr(dist_x)+" disty: "+NumToStr(dist_y);
  SendResponseString(MAILBOX10, deb);

  TextOut(0, LCD_LINE2, "distx: "+NumToStr(dist_x));
  TextOut(0, LCD_LINE3, "disty: "+NumToStr(dist_y));
  OnFwdSync(BOTH_MOTORS, pow, 0);
  Wait(time*1000);
  return 1;
}

int forward(float dist, int pow){
  float time=dist/speed(pow);

  OnFwdSync(BOTH_MOTORS, pow, 0);
  Wait(time*1000);
  return 1;
}

int distance()
{
  SetSensorUltrasonic(S4);
  int list[];
  ArrayInit(list, 0, 5);
  int cpt = 0;
  int ok = 0;
  while(list[4]==0)
  {
    list[cpt]=SensorUS(S4);
    if(list[cpt]<=16) ok++;
    Wait(100);
    cpt++;
  }
  if(ok>=3) return 1;
  else return 0;

}


task catch()
{
  Off(OUT_ABC);
  int sum=0;
  int diff=0;
  short refCompass;
  short compassValue=0;
  int dist=0;

  while(true)
  {
    if(SensorHTCompass(COMPASS_PORT)>=0){compassValue=(SensorHTCompass(COMPASS_PORT));}
    else  {compassValue=360+(SensorHTCompass(COMPASS_PORT));}

    compassValue = abs(SensorHTCompass(COMPASS_PORT));
    diff=compassValue-refCompass;
    sum=(sum+diff);
    sum=sum-(sum/360)*360;

    refCompass=compassValue;
    /*
    ClearScreen();
    TextOut(0, LCD_LINE5, "C: ");
    NumOut(27, LCD_LINE5, compassValue-refCompass);

    TextOut(0, LCD_LINE8, "S: ");
    NumOut(25, LCD_LINE8, sum);
    */
    dist = SensorUS(S4);
    //TextOut(0,0,NumToStr(Sensor(S3))+NumToStr(Sensor(S4)));
    //Wait(200);
    ClearScreen();
    TextOut(0,LCD_LINE3, "Dist: ");
    NumOut(28,LCD_LINE3,dist);
    while(dist>13)
    {
      forward(0.02,22);
      dist= SensorUS(S4);
    }

    OnFwd(OUT_B, 30);
    forward(0.03,15);

    if(distance()==1){
      Off(OUT_ABC);
      break;
    }
    else{
      OnRev(OUT_B, 20);
      Wait(150);
    }
  }

  int target=(sum+180);
  target=target-(target/360)*360;
  while(true)
  {
    compassValue=SensorHTCompass(COMPASS_PORT);
    /*    ClearScreen();
    TextOut(0, LCD_LINE5, "C: ");
    NumOut(27, LCD_LINE5, compassValue);

    TextOut(0, LCD_LINE8, "T: ");
    NumOut(25, LCD_LINE8, target);
    */
    // are we facing North? Make it be so!
    if (compassValue > target-1 && compassValue < target+1)
    {
      forward(0.05, 30);

    } else
    {
      turn(target-compassValue, compassValue);
    }
  }
}


task search()
{
  byte msg[];
  //msg= send_wait()

  OnRev(OUT_B,25);
  Wait(200);
  int list[];
  int i=0;
  ArrayInit(list, 0, 360);
  for(i;i<360;i++)
  {
    list[i]=SensorUS(S4);
    turn(2, SensorHTCompass(COMPASS_PORT));
    Wait(110/4);
    if(i!=0){
      ClearScreen();
      TextOut(0, LCD_LINE3, "%: ");
      NumOut(25, LCD_LINE3, (list[i-1]-list[i])/list[i-1]);
      if(abs((list[i-1]-list[i])/list[i-1])>0.3){
        dist_search=list[i];
        Off(OUT_B);
        ExitTo(catch);  // Surement une balle, on lance catch.
      }
    }
  }
  ExitTo(explore);
  // Pas de balle d�tect�e, task finie.
}


task listen()
{
  if (BluetoothStatus(CONNECTION) != NO_ERR)
  StopAllTasks ();
  else
  TextOut(0, LCD_LINE1, "Conn Success!  ");

  // Wait for START message
  TextOut(0, LCD_LINE2,       "Waiting Msg...");

  while(true){
    until (getMessage (msg))
    if(msg[4]==MSG_START && msg[3]==ACHILLE){
      break;
    }
  }

  TextOut(0, LCD_LINE2,   "START !!!     ");
  byte rank = msg[5];
  byte length = msg[6];
  byte previous = msg[7];
  next_rob = msg[8];

  Wait (50);

  if (rank==0) // Leader -> exploration de l'arene
  {
    StartTask(explore);
  }

  if (rank != length-1) {
    // StartTask(follower);
    // we are not the last robot

/*    byte actionMsg[];
    ArrayInit(actionMsg,0,10);
    actionMsg[0] = 0x00;
    actionMsg[1] = 0x00;
    actionMsg[2] = 0x00;        // ID of the team
    actionMsg[3] = next;
    actionMsg[4] = MSG_ACTION;

    actionMsg[5] = 90;          // angle 90 degree
    actionMsg[6] = 0x00;

    actionMsg[7] = 10;          // dist 10cm

    actionMsg[8] = 20;          // speed 20mm/s
    actionMsg[9] = 0x00;

    sendMessage (actionMsg);*/
  }

  while(true){
    while(!getMessage(msg)){}

    if(msg[4]==MSG_STOP){   // STOP MSG received
      StopAllTasks();
    }

    if(msg[4]== MSG_KICK){    // KICK MSG received
      if(msg[3]==ACHILLE){
        StopAllTasks();
      }
      if(msg[5]==0 && msg[7]==ACHILLE){
        // Stop follower and Start explore we are the leader now.
      }
      if(msg[5]==rank+1){
        // New follower -> get its id.
      }
    }

    if(msg[4]==MSG_LEAD && msg[3]==ACHILLE){    // We are the leader now.
      // Stop follower
      // Start explore
    }

  }
}



task testUS(){
  SetSensorUltrasonic(S4);
  int lol;
  while(true){
    lol= SensorUS(S4);
    ClearScreen();
    NumOut(0, LCD_LINE3, lol);
    Wait(1000);
  }
}

task turnff(){
  turn(-90, SensorHTCompass(COMPASS_PORT));
  turn(+180, SensorHTCompass(COMPASS_PORT));
}

task colorff(){
  string msg1="C: "+NumToStr(SensorHTColorNum(COLOR_PORT));
  string msg2="L: "+NumToStr(Sensor(LIGHT_PORT));
  while(true){
    ClearScreen();
    msg1="C: "+NumToStr(SensorHTColorNum(COLOR_PORT));
    msg2="L: "+NumToStr(Sensor(LIGHT_PORT));
    TextOut(0, LCD_LINE2, msg1);
    TextOut(0, LCD_LINE4, msg2);
    Wait(1500);
  }
}

task explore(){
  int usVal=0;
  int colVal=0;
  int compVal=0;
  int sum=0;
  bool end=false;

  string debug;

  turn(100, SensorHTCompass(COMPASS_PORT)); // direction approx. premiere balle
  forward(0.20, 25);

  while(!end){
    usVal=SensorUS(US_PORT);
    colVal=Sensor(COLOR_PORT);
    compVal=SensorHTCompass(COMPASS_PORT);

    debug="US: "+NumToStr(usVal)+"cV: "+NumToStr(compVal);
    ClearScreen();
    TextOut(0, LCD_LINE3, debug);

    forward(0.04, 25);

    if(usVal < 30){   // quelque chose est devant nous : une balle? On lance search.
      ExitTo(search);
    }
  }
}

task home(){
  TextOut(0, LCD_LINE6, "Refy: "+NumToStr(SensorHTCompass(COMPASS_PORT)));
  ref_y_axis=SensorHTCompass(COMPASS_PORT);
  ref_x_axis=ref_y_axis+90;

  turn(37, ref_y_axis);
  TextOut(0, LCD_LINE7, "Ang: "+NumToStr(SensorHTCompass(COMPASS_PORT)));
  forward_plus(0.70, 40, SensorHTCompass(COMPASS_PORT));

  turn(-60, SensorHTCompass(COMPASS_PORT));
  forward_plus(0.50, 40, SensorHTCompass(COMPASS_PORT));

  if(dist_y > 0){
    turn(-SensorHTCompass(COMPASS_PORT)+ref_y_axis+180, SensorHTCompass(COMPASS_PORT));
  }else{
    dist_y=-dist_y;
    turn(-SensorHTCompass(COMPASS_PORT)+ref_y_axis, SensorHTCompass(COMPASS_PORT));
  }
  forward(dist_y, 40);
  if(dist_x>0){
    turn(90, SensorHTCompass(COMPASS_PORT));
  }else{
    dist_x=-dist_x;
    turn(-90, SensorHTCompass(COMPASS_PORT));
  }
  forward(dist_x, 40);
}

task main()
{
  SetSensorUltrasonic(US_PORT);
  SetSensorLowspeed(COMPASS_PORT);
  SetSensorLowspeed(COLOR_PORT);
  SetSensorLight(LIGHT_PORT, false);

  Precedes(home);
}
