#define CONNECTION  1
//modification de search pour envoyer des messages par bt qd on est leader
#define SERV_NAME   "eurecom-os-server"             // The name of the server
#define MSG_ACTION  0
#define MSG_ACK     1
#define MSG_LEAD    2
#define MSG_START   3
#define MSG_STOP    4
#define MSG_WAIT    5
#define MSG_CUSTOM  6
#define COMPASS_PORT         S1
#define OBSTACLE_THRESHOLD   25

#define LEFT_MOTOR           OUT_C
#define RIGHT_MOTOR          OUT_A
#define BOTH_MOTORS          OUT_AC

#define EXPLORATORY_ITERATIONS 10
#define DIRECTION_LEFT  0
#define DIRECTION_RIGHT 1
#define TURN_RIGHT() \
OnFwd(LEFT_MOTOR, 30);OnRev(RIGHT_MOTOR, 30)
#define TURN_LEFT() \
OnFwd(RIGHT_MOTOR, 30);OnRev(LEFT_MOTOR, 30)

int dist_search=0;

void joy()
{
   PlayTone(TONE_E4, MS_100);
   Wait(MS_100);
   PlayTone(TONE_G4, MS_100);
   Wait(MS_100);
   PlayTone(TONE_C5, MS_100);
   Wait(MS_100);
   PlayTone(TONE_E5, MS_100);
   Wait(MS_100);
   PlayTone(TONE_G5, MS_300);
   Wait(MS_300);
   PlayTone(TONE_E5, MS_100);
   Wait(MS_100);
   PlayTone(TONE_G5, SEC_1);
   Wait(SEC_1);
}
byte next_rob;
task search();

void GoFront()
{
  OnRevSync(OUT_AC,25,1);
}

void CloseTrap()
{
  OnFwd(OUT_B,25);
}

void OpenTrap()
{
  OnRev(OUT_B,25);
}

void GoBack()
{
  OnFwd(OUT_B,25);
}

void TurnLeft(int angle)
{
  OnFwd(OUT_A,25);
  OnRev(OUT_C,25);
  Wait(20*angle);
}

void TurnRight(int angle)
{
  OnFwd(OUT_C,25);
  OnRev(OUT_A,25);
  Wait(90*angle/4);
}

int turn(short angle, short ref){
     int end =0;
     int compValue=SensorHTCompass(COMPASS_PORT);
     int diff=0;
     diff=compValue-ref;
     if(diff<0){
       diff+=360;
     }
     while(compValue-ref > angle+2){
        TextOut(0, LCD_LINE5, "Left");
        NumOut(25, LCD_LINE5, SensorHTCompass(COMPASS_PORT)-ref);
        OnFwd(OUT_A, 22); // turn left
        OnRev(OUT_C,22);
        Wait(20);
        compValue=SensorHTCompass(COMPASS_PORT);
        diff=compValue-ref;
        if(diff<0){
          diff+=360;
        }
        diff=diff=diff-(diff/360)*360;
        //TurnLeft(2);
     }
     while(compValue-ref < angle-2){
        TextOut(0, LCD_LINE5, "Right");
        NumOut(25, LCD_LINE5, SensorHTCompass(COMPASS_PORT)-ref);
        OnFwd(OUT_C, 22); // turn right
        OnRev(OUT_A,22);
        Wait(20);
        compValue=SensorHTCompass(COMPASS_PORT);
        diff=compValue-ref;
        if(diff<0){
          diff+=360;
        }
        diff=diff-(diff/360)*360;
        //TurnRight(2);
     }
     end=1;
}

float speed(int pow){
      return 0.0039*pow-0.0293;
}



int distance()
{
  SetSensorUltrasonic(IN_4);
  int list[];
  ArrayInit(list, 0, 5);
  int cpt = 0;
  int ok = 0;
  while(list[4]==0)
  {
    list[cpt]=SensorUS(IN_4);
    if(list[cpt]<=9) ok++;
    Wait(100);
    cpt++;
  }
  if(ok>=3) return 1;
  else return 0;

}



char getMessage (byte &msg[]) {
  until (BluetoothStatus(CONNECTION) == NO_ERR);  // Wait for connection
  string __msg;
  char r = ReceiveMessage(0,1,__msg);
  if (r != 0)
  return 0;

  ArrayInit(msg,0,59);
  StrToByteArray (__msg, msg);
  r = ArrayLen(msg);
  if (r < 5)
  return 0;

  return r;
}

void sendMessage (byte msg[]) {
  CommBTWriteType args2;
  args2.Connection = CONNECTION;
  args2.Buffer= ByteArrayToStr (msg);

  SysCommBTWrite(args2);
  TextOut(0, LCD_LINE2,       "Trying to write");
  while (BluetoothStatus (CONNECTION) == STAT_COMM_PENDING)
  Wait (10);

  if (BluetoothStatus (CONNECTION) == NO_ERR)
  TextOut(0, LCD_LINE2,   "Write Done     ");
  else
  TextOut(0, LCD_LINE2,   "Write Failed   ");
}



task catch()
{
  Off(OUT_ABC);
  int sum=0;
  int diff=0;
  short refCompass;
  short compassValue=0;
  int dist=0;
  SetSensorLowspeed(COMPASS_PORT);

  while(true)
  {
    if(SensorHTCompass(COMPASS_PORT)>=0){compassValue=(SensorHTCompass(COMPASS_PORT));}
    else  {compassValue=360+(SensorHTCompass(COMPASS_PORT));}

    compassValue = abs(SensorHTCompass(COMPASS_PORT));
    diff=compassValue-refCompass;
    sum=(sum+diff);
    sum=sum-(sum/360)*360;

    refCompass=compassValue;
/*
    ClearScreen();
    TextOut(0, LCD_LINE5, "C: ");
    NumOut(27, LCD_LINE5, compassValue-refCompass);

    TextOut(0, LCD_LINE8, "S: ");
    NumOut(25, LCD_LINE8, sum);
*/
    dist = SensorUS(IN_4);
    //TextOut(0,0,NumToStr(Sensor(S3))+NumToStr(Sensor(S4)));
    //Wait(200);
    ClearScreen();
    TextOut(0,LCD_LINE3, "Dist: ");
    NumOut(28,LCD_LINE3,dist);
    while(dist>13)
    {
     OnFwdSync(BOTH_MOTORS, 22, -1);
     dist= SensorUS(IN_4);
    }
    
    
    OnFwd(OUT_B, 30);
    OnFwdSync(BOTH_MOTORS, 19, -1);
    Wait(150);
    if(distance()==1){
       Off(OUT_ABC);
       break;
    }
    else{
      OnRev(OUT_B, 20);
      Wait(150);
    }



  }
  int target=(sum+180);
  target=target-(target/360)*360;
  while(true)
  {
    compassValue=SensorHTCompass(COMPASS_PORT);
/*    ClearScreen();
    TextOut(0, LCD_LINE5, "C: ");
    NumOut(27, LCD_LINE5, compassValue);

    TextOut(0, LCD_LINE8, "T: ");
    NumOut(25, LCD_LINE8, target);
*/
    // are we facing North? Make it be so!
    if (compassValue > target-4 && compassValue < target+4)
    {
      OnFwdSync(BOTH_MOTORS, 30, 0);
      Wait(500);

    } else
    {
      if(compassValue>target+4)
      {
        TURN_LEFT();
      }
      if(compassValue<target-4)
      {
        TURN_RIGHT();
      }
      Wait(30);
    }

    Wait(20); // This is a good sample rate
  }
}


 /*
  void send_wait(byte &msg[], byte dest, byte delay, byte* id)
  {
    ArrayInit(msg, 0, 6);
    msg[0] = id[0];
    msg[1] = id[1];
    msg[2] = 0x08;
    msg[3] = next_rob;                    //byte or int
    msg[4] = 0x05;
    msg[6] = delay;
  }
*/

task search()
{
  byte msg[];
  //msg= send_wait()

  SetSensorUltrasonic(IN_4);
  OnRev(OUT_B,25);
  Wait(200);
  float list[];
  int i=0;
  ArrayInit(list, 0, 360);
  for(i;i<360;i++)
  {
    list[i]=SensorUS(IN_4);
    TurnRight(1);
    Wait(110/4);
    if(i!=0){
       ClearScreen();
       TextOut(0, LCD_LINE3, "%: ");
       NumOut(25, LCD_LINE3, (list[i-1]-list[i])/list[i-1]);
       if(abs((list[i-1]-list[i])/list[i-1])>0.3){
        TextOut(0, LCD_LINE5, "L[i]: ");
        NumOut(30, LCD_LINE5, list[i]);
        Wait(3000);
        dist_search=list[i];
        break;
       }
    }
  }
  // penser a sortir, no infinite maggle
  Off(OUT_B);
  ExitTo(catch);
}

/*
task listen()
{
  if (BluetoothStatus(CONNECTION) != NO_ERR)
  StopAllTasks ();
  else
  TextOut(0, LCD_LINE1, "Conn Success!  ");

  // Wait for START message
  TextOut(0, LCD_LINE2,       "Waiting Msg...");
  byte msg[];
  until (getMessage (msg))
  Wait (100);

  NumOut(0, LCD_LINE3, msg[4]);
  byte previous = 0xFF;
  byte next = 0xFF;
  byte rank = 0;
  byte length = 0;

  if (msg[4] == MSG_START) {
    TextOut(0, LCD_LINE2,   "START !!!     ");
    rank = msg[5];
    length = msg[6];
    previous = msg[7];
    next_rob = msg[8];
  }

  Wait (50);

  if (rank==0)
  {
    StartTask(search);
  }

  if (rank != length-1) {
    // we are not the last robot
    byte actionMsg[];
    ArrayInit(actionMsg,0,10);
    actionMsg[0] = 0x00;
    actionMsg[1] = 0x00;
    actionMsg[2] = 0x00;        // ID of the team
    actionMsg[3] = next;
    actionMsg[4] = MSG_ACTION;

    actionMsg[5] = 90;          // angle 90 degree
    actionMsg[6] = 0x00;

    actionMsg[7] = 10;          // dist 10cm

    actionMsg[8] = 20;          // speed 20mm/s
    actionMsg[9] = 0x00;

    sendMessage (actionMsg);
  }

  Wait (5000);
}
*/


task testUS(){
   SetSensorUltrasonic(IN_4);
   int lol;
   while(true){
    Wait(300);
    lol= SensorUS(IN_4);
    NumOut(0, LCD_LINE3, lol);
    //ClearScreen();
    }
 }
 
task turnff(){
     SetSensorLowspeed(COMPASS_PORT);
     NumOut(0, LCD_LINE3, SensorHTCompass(COMPASS_PORT));
     turn(90, SensorHTCompass(COMPASS_PORT));
     /*OnFwdSync(BOTH_MOTORS, 40, 0);
     Wait(500000);*/
}

 
task main()
{
     Precedes(turnff);
    //Precedes(search);
}
